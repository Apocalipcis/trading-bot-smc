"""
Telegram client for sending SMC signal notifications
"""
import requests
import json
import logging
from typing import Optional, Dict, Any
from datetime import datetime


class TelegramClient:
    """Client for sending messages via Telegram Bot API"""
    
    def __init__(self, bot_token: str, chat_id: str):
        self.bot_token = bot_token
        self.chat_id = chat_id
        self.base_url = f"https://api.telegram.org/bot{bot_token}"
        self.logger = logging.getLogger(__name__)
        
    def send_message(self, text: str, parse_mode: str = "HTML") -> bool:
        """Send a text message to the configured chat"""
        try:
            url = f"{self.base_url}/sendMessage"
            data = {
                "chat_id": self.chat_id,
                "text": text,
                "parse_mode": parse_mode
            }
            
            response = requests.post(url, data=data, timeout=10)
            response.raise_for_status()
            
            result = response.json()
            if result.get("ok"):
                self.logger.info("Telegram message sent successfully")
                return True
            else:
                self.logger.error(f"Telegram API error: {result.get('description')}")
                return False
                
        except requests.exceptions.RequestException as e:
            self.logger.error(f"Failed to send Telegram message: {e}")
            return False
        except Exception as e:
            self.logger.error(f"Unexpected error sending Telegram message: {e}")
            return False
    
    def send_signal_notification(self, signal: Dict[str, Any]) -> bool:
        """Send a formatted SMC signal notification"""
        try:
            # Format direction emoji
            direction_emoji = "📈" if signal["direction"] == "LONG" else "📉"
            direction_color = "🟢" if signal["direction"] == "LONG" else "🔴"
            
            # Calculate percentages
            entry = float(signal["entry"])
            sl = float(signal["sl"])
            tp = float(signal["tp"])
            
            sl_pct = ((sl - entry) / entry) * 100
            tp_pct = ((tp - entry) / entry) * 100
            
            # Format timestamp
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S UTC")
            
            # Create message
            message = f"""🚨 <b>SMC SIGNAL ALERT</b> 🚨

{direction_color} <b>{signal["direction"]} {signal.get("symbol", "UNKNOWN")}</b>

💰 <b>Entry:</b> {entry:,.4f} USDT
🛑 <b>Stop Loss:</b> {sl:,.4f} USDT ({sl_pct:+.2f}%)
🎯 <b>Take Profit:</b> {tp:,.4f} USDT ({tp_pct:+.2f}%)
⚖️ <b>Risk/Reward:</b> {signal.get("rr", "N/A")}

{direction_emoji} <b>HTF Bias:</b> {signal.get("htf_bias", "Unknown")}
💎 <b>FVG Confluence:</b> {"✅ Yes" if signal.get("fvg_confluence") else "❌ No"}

🕐 <i>{timestamp}</i>

<i>Generated by SMC Trading Bot</i>"""
            
            return self.send_message(message)
            
        except Exception as e:
            self.logger.error(f"Error formatting signal notification: {e}")
            return False
    
    def send_status_update(self, message: str) -> bool:
        """Send a status update message"""
        formatted_message = f"ℹ️ <b>SMC Bot Status</b>\n\n{message}"
        return self.send_message(formatted_message)
    
    def test_connection(self) -> bool:
        """Test the Telegram bot connection"""
        try:
            url = f"{self.base_url}/getMe"
            response = requests.get(url, timeout=10)
            response.raise_for_status()
            
            result = response.json()
            if result.get("ok"):
                bot_info = result.get("result", {})
                self.logger.info(f"Telegram bot connected: @{bot_info.get('username')}")
                return True
            else:
                self.logger.error(f"Telegram bot test failed: {result.get('description')}")
                return False
                
        except Exception as e:
            self.logger.error(f"Failed to test Telegram connection: {e}")
            return False
